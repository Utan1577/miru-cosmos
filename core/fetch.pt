import requests
import re
from bs4 import BeautifulSoup
from urllib.parse import urljoin

from core.config import HEADERS

# ------------------------------------------------------------
# Rakuten fetch helpers
# ------------------------------------------------------------
def get_month_urls(past_url: str) -> list[tuple[int, str]]:
    r = requests.get(past_url, headers=HEADERS, timeout=20)
    r.encoding = r.apparent_encoding or "utf-8"
    soup = BeautifulSoup(r.text, "html.parser")

    months = []
    for a in soup.find_all("a", href=True):
        href = a["href"]
        m = re.search(r"/backnumber/(numbers4|numbers3)/(\d{6})/", href)
        if m:
            ym = int(m.group(2))
            months.append((ym, urljoin(past_url, href)))
    months = sorted(set(months))
    return months


def parse_month_page(month_url: str, digits: int) -> list[dict]:
    """
    Parse Rakuten month page text blocks (inline text).
    We parse by "開催回" blocks and extract:
      - round: 第xxxx回
      - date: YYYY/MM/DD
      - num: digits
      - payout: STR/BOX/SET-S/SET-B (+ MINI for digits==3)
    """
    r = requests.get(month_url, headers=HEADERS, timeout=20)
    r.encoding = r.apparent_encoding or "utf-8"
    soup = BeautifulSoup(r.text, "html.parser")

    lines = [ln.strip() for ln in soup.get_text("\n", strip=True).splitlines() if ln.strip()]

    items = []
    i = 0
    while i < len(lines):
        if lines[i] == "開催回" and i + 1 < len(lines):
            rtxt = lines[i + 1]
            dtxt = None
            ntxt = None
            payout = {}

            # --- scan THIS block only (from this 開催回 to next 開催回)
            end = len(lines)
            for t in range(i + 1, len(lines)):
                if lines[t] == "開催回":
                    end = t
                    break

            # primary scan
            for j in range(i, end):
                if lines[j] in ("抽せん日", "抽選日") and j + 1 < end:
                    dtxt = lines[j + 1]
                if lines[j] in ("当せん番号", "当選番号") and j + 1 < end:
                    ntxt = lines[j + 1]

                if lines[j] == "ストレート" and j + 2 < end:
                    payout["STR"] = {"kuchi": lines[j + 1], "yen": lines[j + 2]}
                if lines[j] == "ボックス" and j + 2 < end:
                    payout["BOX"] = {"kuchi": lines[j + 1], "yen": lines[j + 2]}
                if lines[j].startswith("セット（ストレート）") and j + 2 < end:
                    payout["SET-S"] = {"kuchi": lines[j + 1], "yen": lines[j + 2]}
                if lines[j].startswith("セット（ボックス）") and j + 2 < end:
                    payout["SET-B"] = {"kuchi": lines[j + 1], "yen": lines[j + 2]}

                # Numbers3 mini: try "nearby search" (order may drift)
                if digits == 3 and ("ミニ" in lines[j]):
                    kuchi = ""
                    yen = ""
                    for k in range(j + 1, min(j + 18, end)):
                        if (not kuchi) and lines[k].endswith("口"):
                            kuchi = lines[k]
                        if (not yen) and lines[k].endswith("円"):
                            yen = lines[k]
                    if kuchi and yen:
                        payout["MINI"] = {"kuchi": kuchi, "yen": yen}

            # fallback: regex over whole block (strongest)
            if digits == 3 and ("MINI" not in payout):
                block_text = "\n".join(lines[i:end])
                # allow any spacing / extra chars between fields
                mmini = re.search(r"ミニ.*?([0-9,]+口).*?([0-9,]+円)", block_text)
                if mmini:
                    payout["MINI"] = {"kuchi": mmini.group(1), "yen": mmini.group(2)}

            rm = re.search(r"第(\d+)回", rtxt or "")
            dm = re.search(r"^\d{4}/\d{2}/\d{2}$", dtxt or "")
            nm = re.search(r"^\d{" + str(digits) + r"}$", ntxt or "")

            if rm and dm and nm:
                items.append({
                    "round": int(rm.group(1)),
                    "date": dtxt,
                    "num": ntxt,
                    "payout": payout
                })

            i = end
            continue

        i += 1

    uniq = {it["round"]: it for it in items}
    return sorted(uniq.values(), key=lambda x: x["round"], reverse=True)


def fetch_last_n_results(game: str, need: int = 20) -> tuple[list[dict], list[int]]:
    """
    Returns (items, months_used). items sorted by round desc.
    """
    if game == "N4":
        past = "https://takarakuji.rakuten.co.jp/backnumber/numbers4_past/"
        digits = 4
    elif game == "N3":
        past = "https://takarakuji.rakuten.co.jp/backnumber/numbers3_past/"
        digits = 3
    else:
        raise ValueError("fetch_last_n_results supports N4/N3 only")

    months = get_month_urls(past)
    collected = {}
    used = []

    for ym, murl in reversed(months):
        used.append(ym)
        for it in parse_month_page(murl, digits):
            collected[it["round"]] = it
        if len(collected) >= need:
            break

    items = sorted(collected.values(), key=lambda x: x["round"], reverse=True)[:need]
    return items, used
